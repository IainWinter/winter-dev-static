<html lang="en">

<head>
	<title>Making games with Falling Sand part 1</title>
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<link rel="icon" type="image/x-icon" href="/favicon.ico">
	<link rel="stylesheet" href="/styles/global.css" />
	<link rel="stylesheet" href="/styles/top.css" />
	<link rel="stylesheet" href="/styles/article.css" />
	<link rel="stylesheet" href="/styles/code.css" />
</head>

<script src="/scripts/no_flashbang.js"></script>

<body color-theme="dark">
	<div class="main">
		
		<div class="top">
			<h1 class="title">Winter</h1>
			<div class="nav-section">
				<div class="nav-links">
					<a class="nav-link" href="/articles.html">Articles</a>
					<a class="nav-link" href="/projects.html">Projects</a>
					<a class="nav-link" href="/support.html">Support</a>
				</div>

				<hr class="nav-separator" />

				<div class="nav-buttons">
					<img id="toggle-dark-icon" src="/light_off.svg" onclick="toggleDark();"/>
				</div>
			</div>
		</div>
		<script src="/scripts/toggle_dark.js"></script>
	
		<div class="page">
			<h1 class="page-title">Making games with Falling Sand part 1</h1>
			<span class="article-embed article-embed-thumb-yt-icon">
				<img class="article-embed-thumb" src="/thumbnails/wZJCQQPaGZI.jpg" onclick="swapIframe(this, 'https://www.youtube.com/embed/wZJCQQPaGZI?rel=0&modestbranding=1&autoplay=1')"></img>
			</span>
		<p>Simulating falling sand is no different from any other cellular automata. We have a big gird of cells and a set of rules that get applied to each cell every frame. You've probably heard of the <a class="underline" target="_blank" href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Game of Life</a>. In that cellular automata, the rules are based on the number of neighbors surrounding a cell. For falling sand, we mostly look at if there is empty space below a cell for it to move into. This creates the look of particles cascading down.</p><p>One of the more interesting aspects of cellular automata is how complex behavior can emerge from such simple rules. That sounds like an interesting project could be created from only a few lines of code! Let's look at how you could go about making one of these in the Java version of Processing. You can download Processing <a class="underline" target="_blank" href="https://processing.org/">here</a> if you want to follow along.</p>
			<h2 class="article-subtitle mark-section" id=Java>
				Java version
				<a class="article-subtitle-id-link" href="#Java">#</a>
			</h2>
		<p>We'll start with the standard setup and draw functions. Before we fill these in, we should establish what our particles will be. For simplicity, color will determine the particle types, so let's define some colors at the top.</p>
			<div class="article-code draw-left-line">
				<p class="article-code-file mark-section">sketch.pde</p>
				<pre class="article-code-text processing">
</span><span class="code-t">color </span><span class="code-w">_EMPTY </span><span class="code-s">= </span><span class="code-f">color</span><span class="code-s">(</span><span class="code-d">0</span><span class="code-s">);
</span><span class="code-t">color </span><span class="code-w">_SAND  </span><span class="code-s">= </span><span class="code-f">color</span><span class="code-s">(</span><span class="code-d">255</span><span class="code-s">, </span><span class="code-d">150</span><span class="code-s">, </span><span class="code-d">50</span><span class="code-s">);

</span><span class="code-r">void </span><span class="code-m">setup</span><span class="code-s">(</span><span class="code-s">) </span><span class="code-s">{ 
</span><span class="code-s">}

</span><span class="code-r">void </span><span class="code-m">draw</span><span class="code-s">(</span><span class="code-s">) </span><span class="code-s">{
</span><span class="code-s">}
</span></pre>
			</div>
		<p>In setup we need to set the size and background. I like to use a size of 800x800 pixels, and we need to set the background to the empty particle color. We should also uncap the framerate from 60 to allow this to run faster if it can.</p>
			<div class="article-code draw-left-line">
				
				<pre class="article-code-text processing">
</span><span class="code-r">void </span><span class="code-m">setup</span><span class="code-s">(</span><span class="code-s">) </span><span class="code-s">{
  </span><span class="code-f">size</span><span class="code-s">(</span><span class="code-d">800</span><span class="code-s">, </span><span class="code-d">800</span><span class="code-s">);
  </span><span class="code-f">background</span><span class="code-s">(</span><span class="code-w">_EMPTY</span><span class="code-s">);
  </span><span class="code-f">frameRate</span><span class="code-s">(</span><span class="code-d">1000</span><span class="code-s">);
</span><span class="code-s">}
</span></pre>
			</div>
		<p>Each time the draw function is called we will step our simulation. Because we are only using color, let's use the pixels array as the storage for our cells. Each frame we need to call loadPixels to copy the displayed frame into the pixels array. This first frame will be all  _EMPTY because we called background.</p>
			<div class="article-code draw-left-line">
				
				<pre class="article-code-text processing">
</span><span class="code-r">void </span><span class="code-m">draw</span><span class="code-s">(</span><span class="code-s">) </span><span class="code-s">{
  </span><span class="code-f">loadPixels</span><span class="code-s">(</span><span class="code-s">);
</span></pre>
			</div>
		<p>After we load the pixels, we can iterate over them and check if they match a particle type that we know about.</p>
			<div class="article-code draw-left-line">
				
				<pre class="article-code-text processing">
  </span><span class="code-j">for </span><span class="code-s">(</span><span class="code-t">int </span><span class="code-v">x </span><span class="code-s">= </span><span class="code-d">0; </span><span class="code-v">x </span><span class="code-s">&lt width;  </span><span class="code-v">x</span><span class="code-s">+</span><span class="code-s">+</span><span class="code-s">)
  </span><span class="code-j">for </span><span class="code-s">(</span><span class="code-t">int </span><span class="code-v">y </span><span class="code-s">= </span><span class="code-d">0; </span><span class="code-v">y </span><span class="code-s">&lt height; </span><span class="code-v">y</span><span class="code-s">+</span><span class="code-s">+</span><span class="code-s">) </span><span class="code-s">{
    </span><span class="code-t">color </span><span class="code-v">cell </span><span class="code-s">= </span><span class="code-f">get</span><span class="code-s">(</span><span class="code-v">x</span><span class="code-s">, </span><span class="code-v">y</span><span class="code-s">);
    
    </span><span class="code-j">if </span><span class="code-s">(</span><span class="code-v">cell </span><span class="code-s">=</span><span class="code-s">= </span><span class="code-w">_SAND</span><span class="code-s">) </span><span class="code-s">{
</span></pre>
			</div>
		<p>We want sand to form dune like shapes, so let's encode a pyramid into its rules. We need to check directly below, down to the left, and down to the right.</p><img class="article-embed article-embed-half" src="/articles/falling-sand-simulations/sand.png"></img><p>By default, it should move down if possible, but if that cell is occupied, we'll check the other two directions.</p>
			<div class="article-code draw-left-line">
				
				<pre class="article-code-text processing">
		</span><span class="code-t">boolean </span><span class="code-v">down  </span><span class="code-s">= </span><span class="code-w">isEmpty</span><span class="code-s">(</span><span class="code-v">x</span><span class="code-s">,     </span><span class="code-v">y </span><span class="code-s">+ </span><span class="code-d">1</span><span class="code-s">);
		</span><span class="code-t">boolean </span><span class="code-v">left  </span><span class="code-s">= </span><span class="code-w">isEmpty</span><span class="code-s">(</span><span class="code-v">x </span><span class="code-s">- </span><span class="code-d">1</span><span class="code-s">, </span><span class="code-v">y </span><span class="code-s">+ </span><span class="code-d">1</span><span class="code-s">);
		</span><span class="code-t">boolean </span><span class="code-v">right </span><span class="code-s">= </span><span class="code-w">isEmpty</span><span class="code-s">(</span><span class="code-v">x </span><span class="code-s">+ </span><span class="code-d">1</span><span class="code-s">, </span><span class="code-v">y </span><span class="code-s">+ </span><span class="code-d">1</span><span class="code-s">);

		     </span><span class="code-j">if</span><span class="code-s">(</span><span class="code-v">down</span><span class="code-s">)  </span><span class="code-w">setCell</span><span class="code-s">(</span><span class="code-v">x</span><span class="code-s">,     </span><span class="code-v">y </span><span class="code-s">+ </span><span class="code-d">1</span><span class="code-s">, </span><span class="code-w">_SAND</span><span class="code-s">);
		</span><span class="code-j">else </span><span class="code-j">if</span><span class="code-s">(</span><span class="code-v">left</span><span class="code-s">)  </span><span class="code-w">setCell</span><span class="code-s">(</span><span class="code-v">x </span><span class="code-s">- </span><span class="code-d">1</span><span class="code-s">, </span><span class="code-v">y </span><span class="code-s">+ </span><span class="code-d">1</span><span class="code-s">, </span><span class="code-w">_SAND</span><span class="code-s">);
		</span><span class="code-j">else </span><span class="code-j">if</span><span class="code-s">(</span><span class="code-v">right</span><span class="code-s">) </span><span class="code-w">setCell</span><span class="code-s">(</span><span class="code-v">x </span><span class="code-s">+ </span><span class="code-d">1</span><span class="code-s">, </span><span class="code-v">y </span><span class="code-s">+ </span><span class="code-d">1</span><span class="code-s">, </span><span class="code-w">_SAND</span><span class="code-s">);

		</span><span class="code-j">if </span><span class="code-s">(</span><span class="code-v">down </span><span class="code-s">|</span><span class="code-s">| </span><span class="code-v">left </span><span class="code-s">|</span><span class="code-s">| </span><span class="code-v">right</span><span class="code-s">) </span><span class="code-s">{
			</span><span class="code-w">setCell</span><span class="code-s">(</span><span class="code-v">x</span><span class="code-s">, </span><span class="code-v">y</span><span class="code-s">, </span><span class="code-w">_EMPTY</span><span class="code-s">); 
		</span><span class="code-s">}
	</span><span class="code-s">}
</span></pre>
			</div>
		<p>This looks ok, but the order of if statements matters. Because we put the left check before right, if both spaces are open, the particle will always move left. This creates an artificial look, but we can easily fix it by adding a little randomness to shuffle the direction if both cells are empty.</p>
			<div class="article-code draw-left-line">
				
				<pre class="article-code-text processing">
	</span><span class="code-j">if </span><span class="code-s">(</span><span class="code-v">left </span><span class="code-s">&</span><span class="code-s">& </span><span class="code-v">right</span><span class="code-s">) </span><span class="code-s">{
		</span><span class="code-t">boolean </span><span class="code-v">rand </span><span class="code-s">= </span><span class="code-f">random</span><span class="code-s">(</span><span class="code-d">1</span><span class="code-s">) </span><span class="code-s">&gt </span><span class="code-s">.</span><span class="code-d">5;
		</span><span class="code-v">left  </span><span class="code-s">= </span><span class="code-v">rand;
		</span><span class="code-v">right </span><span class="code-s">= </span><span class="code-s">!</span><span class="code-v">rand;
	</span><span class="code-s">}
</span></pre>
			</div>
		<p>Finally, we can close the for loops and call updatePixels to copy our frame to the display.</p>
			<div class="article-code draw-left-line">
				
				<pre class="article-code-text processing">
	</span><span class="code-s">}

	</span><span class="code-f">updatePixels</span><span class="code-s">(</span><span class="code-s">);
</span><span class="code-s">}
</span></pre>
			</div>
		<p>To draw particles on the screen with the mouse, we can add these lines after loadPixels.</p>
			<div class="article-code draw-left-line">
				
				<pre class="article-code-text processing">
	</span><span class="code-j">if </span><span class="code-s">(</span><span class="code-p">mousePressed</span><span class="code-s">) </span><span class="code-s">{
		</span><span class="code-j">for </span><span class="code-s">(</span><span class="code-t">int </span><span class="code-v">x </span><span class="code-s">= </span><span class="code-d">0; </span><span class="code-v">x </span><span class="code-s">&lt </span><span class="code-d">1; </span><span class="code-v">x</span><span class="code-s">+</span><span class="code-s">+</span><span class="code-s">)
		</span><span class="code-j">for </span><span class="code-s">(</span><span class="code-t">int </span><span class="code-v">y </span><span class="code-s">= </span><span class="code-d">0; </span><span class="code-v">y </span><span class="code-s">&lt </span><span class="code-d">1; </span><span class="code-v">y</span><span class="code-s">+</span><span class="code-s">+</span><span class="code-s">) </span><span class="code-s">{
			</span><span class="code-w">setCell</span><span class="code-s">(</span><span class="code-p">mouseX </span><span class="code-s">+ </span><span class="code-v">x</span><span class="code-s">, </span><span class="code-p">mouseY </span><span class="code-s">+ </span><span class="code-v">y</span><span class="code-s">, </span><span class="code-w">_SAND</span><span class="code-s">);
		</span><span class="code-s">}
	</span><span class="code-s">}
</span></pre>
			</div>
		<p>You can create other particle types by adding more rules in a similar way. For example, water and a stationary barrier type are the most straight forward and where I would start. Water is like sand, but we check directly to the left and right instead of diagonal, which gives the effect of liquid flow. Barriers have no movement properties but fill space so the other types can't move through them.</p><img class="article-embed article-embed-half" src="/articles/falling-sand-simulations/water.png"></img><h3>Common issues</h3><p>I saved the helper functions for last to highlight two common issues. The biggest gotcha with these types of simulations is that the order of iteration effects the behavior dramatically, and if we aren't careful, we could end up updating particles multiple times or even lose them entirely.</p>
			<div class="article-code draw-left-line">
				<p class="article-code-file mark-section">sketch.pde</p>
				<pre class="article-code-text processing">
</span><span class="code-t">boolean </span><span class="code-w">inBounds</span><span class="code-s">(</span><span class="code-t">int </span><span class="code-a">x</span><span class="code-s">, </span><span class="code-t">int </span><span class="code-a">y</span><span class="code-s">) </span><span class="code-s">{
  </span><span class="code-r">return </span><span class="code-a">x </span><span class="code-s">&gt</span><span class="code-s">= </span><span class="code-d">0    </span><span class="code-s">&</span><span class="code-s">& </span><span class="code-a">y </span><span class="code-s">&gt</span><span class="code-s">= </span><span class="code-d">0
      </span><span class="code-s">&</span><span class="code-s">& </span><span class="code-a">x </span><span class="code-s">&lt </span><span class="code-p">width </span><span class="code-s">&</span><span class="code-s">& </span><span class="code-a">y </span><span class="code-s">&lt </span><span class="code-p">height;
</span><span class="code-s">}

</span><span class="code-t">boolean </span><span class="code-w">isEmpty</span><span class="code-s">(</span><span class="code-t">int </span><span class="code-a">x</span><span class="code-s">, </span><span class="code-t">int </span><span class="code-a">y</span><span class="code-s">) </span><span class="code-s">{
  </span><span class="code-r">return </span><span class="code-w">inBounds</span><span class="code-s">(</span><span class="code-a">x</span><span class="code-s">, </span><span class="code-a">y</span><span class="code-s">) </span><span class="code-s">&</span><span class="code-s">& </span><span class="code-p">pixels</span><span class="code-s">[</span><span class="code-a">x </span><span class="code-s">+ </span><span class="code-a">y </span><span class="code-s">* </span><span class="code-p">width</span><span class="code-s">] </span><span class="code-s">=</span><span class="code-s">= </span><span class="code-w">_EMPTY;
</span><span class="code-s">}

</span><span class="code-r">void </span><span class="code-w">setCell</span><span class="code-s">(</span><span class="code-t">int </span><span class="code-a">x</span><span class="code-s">, </span><span class="code-t">int </span><span class="code-a">y</span><span class="code-s">, color </span><span class="code-a">cell</span><span class="code-s">) </span><span class="code-s">{
  </span><span class="code-p">pixels</span><span class="code-s">[</span><span class="code-a">x </span><span class="code-s">+ </span><span class="code-a">y </span><span class="code-s">* </span><span class="code-p">width</span><span class="code-s">] </span><span class="code-s">= </span><span class="code-a">cell;
</span><span class="code-s">}
</span></pre>
			</div>
		<p>We have four options for how we order the iteration. No matter which we pick, there will always be slight issues. Let's see why.</p><p>If we iterate top to bottom, we end up updating the same particle multiple times. This results in a teleportation effect where a particle will only take a single frame to reach the floor. We could change the iteration to bottom to top, but then if we want particles that moves up, we run into the same issue. This highlights the fact that no matter which direction we pick, there will always be issues. Clearly, the solution must have more to it than just finding a magic ordering...</p>
			<span class="article-embed article-embed-thumb-yt-icon">
				<img class="article-embed-thumb" src="/thumbnails/rh_AZGzRTcQ.jpg" onclick="swapIframe(this, 'https://www.youtube.com/embed/rh_AZGzRTcQ?rel=0&modestbranding=1&autoplay=1')"></img>
			</span>
		<p>The band aid solution in this Processing version comes from the subtle details of how the pixel array works. In the helper functions we read and write to the pixels array, but in draw we use the get function. Even though the docs don't say this, get must read from the displayed pixels array, which we don't update until we call updatePixels. This allows us to dodge the issue of updating particles multiple times because nothing updates until the end of the frame from get's perspective.</p><p>The second problem we can only mitigate. In isEmpty we don't use get because we want information about the current frame as it updates. If we used get, two particles could both think a cell is empty, move in, and one would be lost. Even though we've somewhat fixed that issue, the order of iteration still matters. Now the order on the X axis determines who moves in first, so we still have inconsistent behavior.</p><img class="article-embed article-embed-half" src="/articles/falling-sand-simulations/conflict.png"></img><p>Now that we have an idea of how the basics work, and common pitfalls, let's jump over to C++ and see how these can be solved.</p>
			<h2 class="article-subtitle mark-section" id=C++>
				C++ Version
				<a class="article-subtitle-id-link" href="#C++">#</a>
			</h2>
		<p>I plan on expanding this over the next few videos, so I am going to try and make it more of a general sand framework. To start, we don't want to edit the pixels directly because we want more properties than just color. Let's make a CellType enum and store it in a Cell struct along with a Color. In the first version, sand and water both needed to check if the space directly below was free. This hints that the ways that the particles move doesn't have to reflect their type. So, let's keep two enums in each Cell, one for the movement properties and another the type. If we use a bit string for the properties, they can be combined to create more complex patterns.</p>
			<div class="article-code draw-left-line">
				<p class="article-code-file mark-section">Cell.h</p>
				<pre class="article-code-text cpp">
</span><span class="code-r">enum </span><span class="code-t">CellProperties </span><span class="code-s">{
	</span><span class="code-d">NONE           </span><span class="code-s">= </span><span class="code-d">0b0</span><span class="code-d">0000000</span><span class="code-s">,
	</span><span class="code-d">MOVE_DOWN      </span><span class="code-s">= </span><span class="code-d">0b0</span><span class="code-d">0000001</span><span class="code-s">,
	</span><span class="code-d">MOVE_DOWN_SIDE </span><span class="code-s">= </span><span class="code-d">0b0</span><span class="code-d">0000010</span><span class="code-s">,
	</span><span class="code-d">MOVE_SIDE      </span><span class="code-s">= </span><span class="code-d">0b0</span><span class="code-d">0000100
</span><span class="code-s">};

</span><span class="code-r">inline </span><span class="code-t">CellProperties </span><span class="code-s">operator|</span><span class="code-s">(</span><span class="code-t">CellProperties </span><span class="code-a">a</span><span class="code-s">, </span><span class="code-t">CellProperties </span><span class="code-a">b</span><span class="code-s">) </span><span class="code-s">{
	</span><span class="code-j">return </span><span class="code-t">CellProperties</span><span class="code-s">(</span><span class="code-s">(</span><span class="code-r">int</span><span class="code-s">)</span><span class="code-a">a </span><span class="code-s">| </span><span class="code-s">(</span><span class="code-r">int</span><span class="code-s">)</span><span class="code-a">b</span><span class="code-s">);
</span><span class="code-s">}
 
</span><span class="code-r">inline </span><span class="code-r">auto </span><span class="code-s">operator&</span><span class="code-s">(</span><span class="code-t">CellProperties </span><span class="code-a">a</span><span class="code-s">, </span><span class="code-t">CellProperties </span><span class="code-a">b</span><span class="code-s">) </span><span class="code-s">{
	</span><span class="code-j">return </span><span class="code-s">(</span><span class="code-r">int</span><span class="code-s">)</span><span class="code-a">a </span><span class="code-s">& </span><span class="code-s">(</span><span class="code-r">int</span><span class="code-s">)</span><span class="code-a">b;
</span><span class="code-s">}

</span><span class="code-r">enum </span><span class="code-t">CellType </span><span class="code-s">{
	</span><span class="code-d">EMPTY</span><span class="code-s">,
	</span><span class="code-d">SAND</span><span class="code-s">,
	</span><span class="code-d">WATER</span><span class="code-s">,
	</span><span class="code-d">ROCK
</span><span class="code-s">};
 
</span><span class="code-r">struct </span><span class="code-t">Cell </span><span class="code-s">{
	</span><span class="code-t">CellType       </span><span class="code-w">Type  </span><span class="code-s">= </span><span class="code-t">CellType</span><span class="code-s">::</span><span class="code-d">EMPTY;
	</span><span class="code-t">CellProperties </span><span class="code-w">Props </span><span class="code-s">= </span><span class="code-t">CellProperties</span><span class="code-s">::</span><span class="code-d">NONE;

	</span><span class="code-t">Color </span><span class="code-w">Color; </span><span class="code-c">// rgba
</span><span class="code-s">};
</span></pre>
			</div>
		<p>Now that we have defined our Cell, we need a way to store them. Let's make a new class called SandWorld and store an array of Cells in it. In the constructor we can specify a width, height, and scale in pixels. This will allow us to easily change the size of the cells.</p>
			<div class="article-code draw-left-line">
				<p class="article-code-file mark-section">SandWorld.h</p>
				<pre class="article-code-text cpp">
</span><span class="code-r">class </span><span class="code-t">SandWorld </span><span class="code-s">{
</span><span class="code-r">public</span><span class="code-s">:
	</span><span class="code-r">const </span><span class="code-t">size_t </span><span class="code-w">m_width  </span><span class="code-s">= </span><span class="code-d">0;
	</span><span class="code-r">const </span><span class="code-t">size_t </span><span class="code-w">m_height </span><span class="code-s">= </span><span class="code-d">0;
	</span><span class="code-r">const </span><span class="code-r">double </span><span class="code-w">m_scale </span><span class="code-s">= </span><span class="code-d">1;
</span><span class="code-r">private</span><span class="code-s">:
	</span><span class="code-t">Cell</span><span class="code-s">* </span><span class="code-w">m_cells </span><span class="code-s">= </span><span class="code-r">nullptr;

</span><span class="code-r">public</span><span class="code-s">:
	</span><span class="code-f">SandWorld</span><span class="code-s">(</span><span class="code-t">size_t </span><span class="code-a">width</span><span class="code-s">, </span><span class="code-t">size_t </span><span class="code-a">height</span><span class="code-s">, </span><span class="code-r">double </span><span class="code-a">scale</span><span class="code-s">)
		</span><span class="code-s">: </span><span class="code-w">m_width  </span><span class="code-s">(</span><span class="code-a">width  </span><span class="code-s">/ </span><span class="code-a">scale</span><span class="code-s">)
		</span><span class="code-s">, </span><span class="code-w">m_height </span><span class="code-s">(</span><span class="code-a">height </span><span class="code-s">/ </span><span class="code-a">scale</span><span class="code-s">)
		</span><span class="code-s">, </span><span class="code-w">m_scale  </span><span class="code-s">(</span><span class="code-a">scale</span><span class="code-s">)
	</span><span class="code-s">{
		</span><span class="code-w">m_cells </span><span class="code-s">= </span><span class="code-r">new </span><span class="code-t">Cell</span><span class="code-s">[</span><span class="code-w">m_width </span><span class="code-s">* </span><span class="code-w">m_height</span><span class="code-s">];
	</span><span class="code-s">}

	</span><span class="code-f">~SandWorld</span><span class="code-s">(</span><span class="code-s">) </span><span class="code-s">{
		</span><span class="code-r">delete</span><span class="code-s">[</span><span class="code-s">] </span><span class="code-w">m_cells;
	</span><span class="code-s">}
</span></pre>
			</div>
		<p>We'll need some functions for getting the cells out of the world, let's add two: one that takes x and y coordinates, and another that takes a flat index.</p>
			<div class="article-code draw-left-line">
				
				<pre class="article-code-text cpp">
	</span><span class="code-r">const </span><span class="code-t">Cell</span><span class="code-s">& </span><span class="code-f">GetCell</span><span class="code-s">(</span><span class="code-t">size_t </span><span class="code-a">index</span><span class="code-s">) </span><span class="code-s">{
		</span><span class="code-j">return </span><span class="code-w">m_cells</span><span class="code-s">[</span><span class="code-a">index</span><span class="code-s">]; 
	</span><span class="code-s">}

	</span><span class="code-r">const </span><span class="code-t">Cell</span><span class="code-s">& </span><span class="code-f">GetCell</span><span class="code-s">(</span><span class="code-t">size_t </span><span class="code-a">x</span><span class="code-s">, </span><span class="code-t">size_t </span><span class="code-a">y</span><span class="code-s">) </span><span class="code-s">{
		</span><span class="code-j">return </span><span class="code-f">GetCell</span><span class="code-s">(</span><span class="code-f">GetIndex</span><span class="code-s">(</span><span class="code-a">x</span><span class="code-s">, </span><span class="code-a">y</span><span class="code-s">)</span><span class="code-s">);
	</span><span class="code-s">}

	</span><span class="code-t">size_t </span><span class="code-f">GetIndex</span><span class="code-s">(</span><span class="code-t">size_t </span><span class="code-a">x</span><span class="code-s">, </span><span class="code-t">size_t </span><span class="code-a">y</span><span class="code-s">) </span><span class="code-s">{
		</span><span class="code-j">return </span><span class="code-a">x </span><span class="code-s">+ </span><span class="code-a">y </span><span class="code-s">* </span><span class="code-w">m_width;
	</span><span class="code-s">}
</span></pre>
			</div>
		<p>And to get us back to where we were, let's add the same helper functions from before.</p>
			<div class="article-code draw-left-line">
				
				<pre class="article-code-text cpp">
	</span><span class="code-r">bool </span><span class="code-f">InBounds</span><span class="code-s">(</span><span class="code-t">size_t </span><span class="code-a">x</span><span class="code-s">, </span><span class="code-t">size_t </span><span class="code-a">y</span><span class="code-s">) </span><span class="code-s">{
		</span><span class="code-j">return </span><span class="code-a">x </span><span class="code-s">&lt </span><span class="code-w">m_width 
			</span><span class="code-s">&</span><span class="code-s">& </span><span class="code-a">y </span><span class="code-s">&lt </span><span class="code-w">m_height;
	</span><span class="code-s">}

	</span><span class="code-r">bool </span><span class="code-f">IsEmpty</span><span class="code-s">(</span><span class="code-t">size_t </span><span class="code-a">x</span><span class="code-s">, </span><span class="code-t">size_t </span><span class="code-a">y</span><span class="code-s">) </span><span class="code-s">{
		</span><span class="code-j">return </span><span class="code-f">InBounds</span><span class="code-s">(</span><span class="code-a">x</span><span class="code-s">, </span><span class="code-a">y</span><span class="code-s">) 
			</span><span class="code-s">&</span><span class="code-s">& </span><span class="code-f">GetCell</span><span class="code-s">(</span><span class="code-a">x</span><span class="code-s">, </span><span class="code-a">y</span><span class="code-s">)</span><span class="code-s">.</span><span class="code-w">Type </span><span class="code-s">=</span><span class="code-s">= </span><span class="code-t">CellType</span><span class="code-s">::</span><span class="code-d">EMPTY;
	</span><span class="code-s">}

	</span><span class="code-r">void </span><span class="code-f">SetCell</span><span class="code-s">(</span><span class="code-t">size_t </span><span class="code-a">x</span><span class="code-s">, </span><span class="code-t">size_t </span><span class="code-a">y</span><span class="code-s">, </span><span class="code-r">const </span><span class="code-t">Cell</span><span class="code-s">& </span><span class="code-a">cell</span><span class="code-s">) </span><span class="code-s">{
		</span><span class="code-w">m_cells</span><span class="code-s">[GetIndex</span><span class="code-s">(</span><span class="code-a">x</span><span class="code-s">, </span><span class="code-a">y</span><span class="code-s">)</span><span class="code-s">] </span><span class="code-s">= </span><span class="code-a">cell;
	</span><span class="code-s">}
</span></pre>
			</div>
		<p>Processing gave us two arrays to work with, but before we just add another one and call it a day, let's think about a way to actually solve the issues that arise from the iteration ordering. The main problem is that moves are executed as they come, but really, we should gather all the possible moves, then execute them at the end to give each one a fair chance.</p><p>Let's add a vector to the SandWorld, and make a new function called MoveCell that adds a move to the list.</p>
			<div class="article-code draw-left-line">
				
				<pre class="article-code-text cpp">
	</span><span class="code-w">std</span><span class="code-s">::</span><span class="code-t">vector</span><span class="code-s">&lt</span><span class="code-w">std</span><span class="code-s">::</span><span class="code-t">pair</span><span class="code-s">&lt</span><span class="code-t">size_t</span><span class="code-s">, </span><span class="code-t">size_t</span><span class="code-s">&gt</span><span class="code-s">&gt </span><span class="code-w">m_changes; </span><span class="code-c">// destination, source

	</span><span class="code-r">void </span><span class="code-f">MoveCell</span><span class="code-s">(</span><span class="code-t">size_t </span><span class="code-a">x</span><span class="code-s">, </span><span class="code-t">size_t </span><span class="code-a">y</span><span class="code-s">, </span><span class="code-t">size_t </span><span class="code-a">xto</span><span class="code-s">, </span><span class="code-t">size_t </span><span class="code-a">yto</span><span class="code-s">)
	</span><span class="code-s">{
		</span><span class="code-w">m_changes</span><span class="code-s">.</span><span class="code-f">emplace_back</span><span class="code-s">(
			</span><span class="code-f">GetIndex</span><span class="code-s">(</span><span class="code-a">xto</span><span class="code-s">, </span><span class="code-a">yto</span><span class="code-s">)</span><span class="code-s">,
			</span><span class="code-f">GetIndex</span><span class="code-s">(</span><span class="code-a">x</span><span class="code-s">,   </span><span class="code-a">y</span><span class="code-s">)
		</span><span class="code-s">);
	</span><span class="code-s">}
</span></pre>
			</div>
		<p>After we finish iterating over our cells, we can apply the changes. First, we need to remove any changes that were filled between frames by the SetCell function.</p>
			<div class="article-code draw-left-line">
				
				<pre class="article-code-text cpp">
	</span><span class="code-r">void </span><span class="code-f">CommitCells</span><span class="code-s">(</span><span class="code-s">) </span><span class="code-s">{
		</span><span class="code-c">// remove moves that have their destinations filled

		</span><span class="code-j">for </span><span class="code-s">(</span><span class="code-t">size_t </span><span class="code-v">i </span><span class="code-s">= </span><span class="code-d">0; </span><span class="code-v">i </span><span class="code-s">&lt </span><span class="code-w">m_changes</span><span class="code-s">.</span><span class="code-f">size</span><span class="code-s">(</span><span class="code-s">); </span><span class="code-v">i</span><span class="code-s">+</span><span class="code-s">+</span><span class="code-s">) </span><span class="code-s">{
			</span><span class="code-j">if </span><span class="code-s">(</span><span class="code-w">m_cells</span><span class="code-s">[</span><span class="code-w">m_changes</span><span class="code-s">[</span><span class="code-v">i</span><span class="code-s">]</span><span class="code-s">.</span><span class="code-w">first</span><span class="code-s">]</span><span class="code-s">.</span><span class="code-w">Type </span><span class="code-s">!</span><span class="code-s">= </span><span class="code-t">CellType</span><span class="code-s">::</span><span class="code-d">EMPTY</span><span class="code-s">) </span><span class="code-s">{
				</span><span class="code-w">m_changes</span><span class="code-s">[</span><span class="code-v">i</span><span class="code-s">] </span><span class="code-s">= </span><span class="code-w">m_changes</span><span class="code-s">.</span><span class="code-f">back</span><span class="code-s">(</span><span class="code-s">); </span><span class="code-w">m_changes</span><span class="code-s">.</span><span class="code-f">pop_back</span><span class="code-s">(</span><span class="code-s">);
				</span><span class="code-v">i</span><span class="code-s">-</span><span class="code-s">-;
			</span><span class="code-s">}
		</span><span class="code-s">}
</span></pre>
			</div>
		<p>Then we need to sort the list of moves by their destination. This is an unfortunate slowdown but allows us to add and choose moves quicker. We could use a multimap, but the slowdown from accessing the linked lists outweighs the sort.</p>
			<div class="article-code draw-left-line">
				
				<pre class="article-code-text cpp">
		</span><span class="code-c">// sort by destination

		</span><span class="code-w">std</span><span class="code-s">::</span><span class="code-f">sort</span><span class="code-s">(</span><span class="code-w">m_changes</span><span class="code-s">.begin</span><span class="code-s">(</span><span class="code-s">)</span><span class="code-s">, </span><span class="code-w">m_changes</span><span class="code-s">.</span><span class="code-f">end</span><span class="code-s">(</span><span class="code-s">)</span><span class="code-s">,
			</span><span class="code-s">[</span><span class="code-s">]</span><span class="code-s">(</span><span class="code-r">auto</span><span class="code-s">& </span><span class="code-a">a</span><span class="code-s">, </span><span class="code-r">auto</span><span class="code-s">& </span><span class="code-a">b</span><span class="code-s">) </span><span class="code-s">{ </span><span class="code-j">return </span><span class="code-a">a</span><span class="code-s">.</span><span class="code-w">first </span><span class="code-s">&lt </span><span class="code-a">b</span><span class="code-s">.</span><span class="code-w">first; </span><span class="code-s">}
		</span><span class="code-s">);
</span></pre>
			</div>
		<p>Then we can iterate over the sorted moves. Each time the destination changes, we'll pick a random source to move from. This allows each particle to get a fair chance at moving into to a cell. Finally, we'll clear the list.</p>
			<div class="article-code draw-left-line">
				
				<pre class="article-code-text cpp">
		</span><span class="code-c">// pick random source for each destination

		</span><span class="code-t">size_t </span><span class="code-v">iprev </span><span class="code-s">= </span><span class="code-d">0;

		</span><span class="code-w">m_changes</span><span class="code-s">.</span><span class="code-f">emplace_back</span><span class="code-s">(</span><span class="code-s">-</span><span class="code-d">1</span><span class="code-s">, </span><span class="code-s">-</span><span class="code-d">1</span><span class="code-s">); </span><span class="code-c">// to catch final move

		</span><span class="code-j">for </span><span class="code-s">(</span><span class="code-t">size_t </span><span class="code-v">i </span><span class="code-s">= </span><span class="code-d">0; </span><span class="code-v">i </span><span class="code-s">&lt </span><span class="code-w">m_changes</span><span class="code-s">.</span><span class="code-f">size</span><span class="code-s">(</span><span class="code-s">) </span><span class="code-s">- </span><span class="code-d">1; </span><span class="code-v">i</span><span class="code-s">+</span><span class="code-s">+</span><span class="code-s">) </span><span class="code-s">{
			</span><span class="code-j">if </span><span class="code-s">(</span><span class="code-w">m_changes</span><span class="code-s">[</span><span class="code-v">i </span><span class="code-s">+ </span><span class="code-d">1</span><span class="code-s">]</span><span class="code-s">.first </span><span class="code-s">!</span><span class="code-s">= </span><span class="code-w">m_changes</span><span class="code-s">[</span><span class="code-v">i</span><span class="code-s">]</span><span class="code-s">.</span><span class="code-w">first</span><span class="code-s">) </span><span class="code-s">{
				</span><span class="code-t">size_t </span><span class="code-v">rand </span><span class="code-s">= </span><span class="code-v">iprev </span><span class="code-s">+ </span><span class="code-f">rand_int</span><span class="code-s">(</span><span class="code-v">i </span><span class="code-s">- </span><span class="code-v">iprev</span><span class="code-s">);

				</span><span class="code-t">size_t </span><span class="code-v">dst </span><span class="code-s">= </span><span class="code-w">m_changes</span><span class="code-s">[</span><span class="code-v">rand</span><span class="code-s">]</span><span class="code-s">.</span><span class="code-w">first;
				</span><span class="code-t">size_t </span><span class="code-v">src </span><span class="code-s">= </span><span class="code-w">m_changes</span><span class="code-s">[</span><span class="code-v">rand</span><span class="code-s">]</span><span class="code-s">.</span><span class="code-w">second;

				</span><span class="code-w">m_cells</span><span class="code-s">[</span><span class="code-v">dst</span><span class="code-s">] </span><span class="code-s">= </span><span class="code-w">m_cells</span><span class="code-s">[</span><span class="code-v">src</span><span class="code-s">];
				</span><span class="code-w">m_cells</span><span class="code-s">[</span><span class="code-v">src</span><span class="code-s">] </span><span class="code-s">= </span><span class="code-t">Cell</span><span class="code-s">(</span><span class="code-s">);

				</span><span class="code-v">iprev </span><span class="code-s">= </span><span class="code-v">i </span><span class="code-s">+ </span><span class="code-d">1;
			</span><span class="code-s">}
		</span><span class="code-s">}

		</span><span class="code-w">m_changes</span><span class="code-s">.</span><span class="code-f">clear</span><span class="code-s">(</span><span class="code-s">);
	</span><span class="code-s">}
</span><span class="code-s">};
</span></pre>
			</div>
		<p>That's it for the core of our little framework, let's see how we can use it to make what we had in the Processing version. I am going to skip over the rendering details because C++ makes that really annoying. I suggest checking out <a class="underline" target="_blank" href="https://www.libsdl.org/">SDL</a> if you don't already have your own solution.</p><p>In an Update function, we'll iterate over the cells in a similar way as before, but now that we have a bit string of movement properties, we can check each one until its respective MoveX function returns true.</p>
			<div class="article-code draw-left-line">
				<p class="article-code-file mark-section">Main.cpp</p>
				<pre class="article-code-text cpp">
</span><span class="code-t">SandWorld </span><span class="code-w">m_world </span><span class="code-s">= </span><span class="code-t">SandWorld</span><span class="code-s">(</span><span class="code-d">1920</span><span class="code-s">, </span><span class="code-d">1080</span><span class="code-s">, </span><span class="code-d">2</span><span class="code-s">);

</span><span class="code-r">void </span><span class="code-f">Update</span><span class="code-s">(</span><span class="code-s">) </span><span class="code-s">{
	</span><span class="code-c">// Update cells

	</span><span class="code-j">for </span><span class="code-s">(</span><span class="code-t">size_t </span><span class="code-v">x </span><span class="code-s">= </span><span class="code-d">0; </span><span class="code-v">x </span><span class="code-s">&lt </span><span class="code-w">m_world</span><span class="code-s">.</span><span class="code-w">m_width;  </span><span class="code-v">x</span><span class="code-s">+</span><span class="code-s">+</span><span class="code-s">)
	</span><span class="code-j">for </span><span class="code-s">(</span><span class="code-t">size_t </span><span class="code-v">y </span><span class="code-s">= </span><span class="code-d">0; </span><span class="code-v">y </span><span class="code-s">&lt </span><span class="code-w">m_world</span><span class="code-s">.</span><span class="code-w">m_height; </span><span class="code-v">y</span><span class="code-s">+</span><span class="code-s">+</span><span class="code-s">) </span><span class="code-s">{
		</span><span class="code-r">const </span><span class="code-t">Cell</span><span class="code-s">& </span><span class="code-v">cell </span><span class="code-s">= </span><span class="code-w">m_world</span><span class="code-s">.</span><span class="code-f">GetCell</span><span class="code-s">(</span><span class="code-v">x</span><span class="code-s">, </span><span class="code-v">y</span><span class="code-s">);

			</span><span class="code-j">if </span><span class="code-s">(</span><span class="code-v">cell</span><span class="code-s">.</span><span class="code-w">Props </span><span class="code-s">& </span><span class="code-t">CellProperties</span><span class="code-s">::</span><span class="code-d">MOVE_DOWN      </span><span class="code-s">&</span><span class="code-s">& </span><span class="code-f">MoveDown    </span><span class="code-s">(</span><span class="code-v">x</span><span class="code-s">, </span><span class="code-v">y</span><span class="code-s">, </span><span class="code-v">cell</span><span class="code-s">)</span><span class="code-s">) </span><span class="code-s">{</span><span class="code-s">}
		</span><span class="code-j">else </span><span class="code-j">if </span><span class="code-s">(</span><span class="code-v">cell</span><span class="code-s">.</span><span class="code-w">Props </span><span class="code-s">& </span><span class="code-t">CellProperties</span><span class="code-s">::</span><span class="code-d">MOVE_DOWN_SIDE </span><span class="code-s">&</span><span class="code-s">& </span><span class="code-f">MoveDownSide</span><span class="code-s">(</span><span class="code-v">x</span><span class="code-s">, </span><span class="code-v">y</span><span class="code-s">, </span><span class="code-v">cell</span><span class="code-s">)</span><span class="code-s">) </span><span class="code-s">{</span><span class="code-s">}
		</span><span class="code-j">else </span><span class="code-j">if </span><span class="code-s">(</span><span class="code-v">cell</span><span class="code-s">.</span><span class="code-w">Props </span><span class="code-s">& </span><span class="code-t">CellProperties</span><span class="code-s">::</span><span class="code-d">MOVE_SIDE      </span><span class="code-s">&</span><span class="code-s">& </span><span class="code-f">MoveSide    </span><span class="code-s">(</span><span class="code-v">x</span><span class="code-s">, </span><span class="code-v">y</span><span class="code-s">, </span><span class="code-v">cell</span><span class="code-s">)</span><span class="code-s">) </span><span class="code-s">{</span><span class="code-s">}
	</span><span class="code-s">}

	</span><span class="code-w">m_world</span><span class="code-s">.</span><span class="code-f">CommitCells</span><span class="code-s">(</span><span class="code-s">);

	</span><span class="code-c">// Update the sand texture
	</span><span class="code-c">// Draw the sand to the screen
</span><span class="code-s">}
</span></pre>
			</div>
		<p>We can make a function for each movement property that will return true if it finds a valid move.</p>
			<div class="article-code draw-left-line">
				
				<pre class="article-code-text cpp">
</span><span class="code-r">bool </span><span class="code-f">MoveDown</span><span class="code-s">(</span><span class="code-t">size_t </span><span class="code-a">x</span><span class="code-s">, </span><span class="code-t">size_t </span><span class="code-a">y</span><span class="code-s">, </span><span class="code-r">const Cell</span><span class="code-s">& </span><span class="code-a">cell</span><span class="code-s">)
</span><span class="code-s">{
	</span><span class="code-r">bool </span><span class="code-v">down </span><span class="code-s">= </span><span class="code-w">m_world</span><span class="code-s">.</span><span class="code-f">IsEmpty</span><span class="code-s">(</span><span class="code-a">x</span><span class="code-s">, </span><span class="code-a">y </span><span class="code-s">- </span><span class="code-d">1</span><span class="code-s">);
	</span><span class="code-j">if </span><span class="code-s">(</span><span class="code-v">down</span><span class="code-s">) </span><span class="code-s">{
		</span><span class="code-w">m_world</span><span class="code-s">.</span><span class="code-f">MoveCell</span><span class="code-s">(</span><span class="code-a">x</span><span class="code-s">, </span><span class="code-a">y</span><span class="code-s">, </span><span class="code-a">x</span><span class="code-s">, </span><span class="code-a">y </span><span class="code-s">- </span><span class="code-d">1</span><span class="code-s">);
	</span><span class="code-s">}

	</span><span class="code-j">return </span><span class="code-v">down;
</span><span class="code-s">}

</span><span class="code-r">bool </span><span class="code-f">MoveDownSide</span><span class="code-s">(</span><span class="code-t">size_t </span><span class="code-a">x</span><span class="code-s">, </span><span class="code-t">size_t </span><span class="code-a">y</span><span class="code-s">, </span><span class="code-r">const Cell</span><span class="code-s">& </span><span class="code-a">cell</span><span class="code-s">)
</span><span class="code-s">{
	</span><span class="code-r">bool </span><span class="code-v">downLeft  </span><span class="code-s">= </span><span class="code-w">m_world</span><span class="code-s">.</span><span class="code-f">IsEmpty</span><span class="code-s">(</span><span class="code-a">x </span><span class="code-s">- </span><span class="code-d">1</span><span class="code-s">, </span><span class="code-a">y </span><span class="code-s">- </span><span class="code-d">1</span><span class="code-s">);
	</span><span class="code-r">bool </span><span class="code-v">downRight </span><span class="code-s">= </span><span class="code-w">m_world</span><span class="code-s">.</span><span class="code-f">IsEmpty</span><span class="code-s">(</span><span class="code-a">x </span><span class="code-s">+ </span><span class="code-d">1</span><span class="code-s">, </span><span class="code-a">y </span><span class="code-s">- </span><span class="code-d">1</span><span class="code-s">);

	</span><span class="code-j">if </span><span class="code-s">(</span><span class="code-v">downLeft </span><span class="code-s">&</span><span class="code-s">& </span><span class="code-v">downRight</span><span class="code-s">) </span><span class="code-s">{
		</span><span class="code-v">downLeft  </span><span class="code-s">= </span><span class="code-f">rand_float</span><span class="code-s">(</span><span class="code-s">) </span><span class="code-s">&gt </span><span class="code-d">0;
		</span><span class="code-v">downRight </span><span class="code-s">= </span><span class="code-s">!</span><span class="code-v">downLeft;
	</span><span class="code-s">}

		</span><span class="code-j">if </span><span class="code-s">(</span><span class="code-v">downLeft</span><span class="code-s">)  </span><span class="code-w">m_world</span><span class="code-s">.</span><span class="code-f">MoveCell</span><span class="code-s">(</span><span class="code-a">x</span><span class="code-s">, </span><span class="code-a">y</span><span class="code-s">, </span><span class="code-a">x </span><span class="code-s">- </span><span class="code-d">1</span><span class="code-s">, </span><span class="code-a">y </span><span class="code-s">- </span><span class="code-d">1</span><span class="code-s">);
	</span><span class="code-j">else </span><span class="code-j">if </span><span class="code-s">(</span><span class="code-v">downRight</span><span class="code-s">) </span><span class="code-w">m_world</span><span class="code-s">.</span><span class="code-f">MoveCell</span><span class="code-s">(</span><span class="code-a">x</span><span class="code-s">, </span><span class="code-a">y</span><span class="code-s">, </span><span class="code-a">x </span><span class="code-s">+ </span><span class="code-d">1</span><span class="code-s">, </span><span class="code-a">y </span><span class="code-s">- </span><span class="code-d">1</span><span class="code-s">);

	</span><span class="code-j">return </span><span class="code-v">downLeft </span><span class="code-s">|</span><span class="code-s">| </span><span class="code-v">downRight;
</span><span class="code-s">}
</span></pre>
			</div>
		<p>To draw particles with the mouse, we can create some defaults in an Init function...</p>
			<div class="article-code draw-left-line">
				
				<pre class="article-code-text cpp">
</span><span class="code-t">Cell </span><span class="code-w">_EMPTY</span><span class="code-s">, </span><span class="code-w">_SAND</span><span class="code-s">, </span><span class="code-w">_WATER</span><span class="code-s">, </span><span class="code-w">_ROCK;
	
</span><span class="code-r">void </span><span class="code-f">Initialize</span><span class="code-s">(</span><span class="code-s">) </span><span class="code-s">{ 
	</span><span class="code-w">_EMPTY </span><span class="code-s">= </span><span class="code-s">{
		</span><span class="code-t">CellType</span><span class="code-s">::</span><span class="code-d">EMPTY</span><span class="code-s">,
		</span><span class="code-t">CellProperties</span><span class="code-s">::</span><span class="code-d">NONE</span><span class="code-s">,
		</span><span class="code-t">Color</span><span class="code-s">::</span><span class="code-f">From2</span><span class="code-d">55</span><span class="code-s">(</span><span class="code-d">0</span><span class="code-s">, </span><span class="code-d">0</span><span class="code-s">, </span><span class="code-d">0</span><span class="code-s">, </span><span class="code-d">0</span><span class="code-s">) </span><span class="code-c">// 0 alpha allows for a background
	</span><span class="code-s">};
	
	</span><span class="code-w">_SAND </span><span class="code-s">= </span><span class="code-s">{
		</span><span class="code-t">CellType</span><span class="code-s">::</span><span class="code-d">SAND</span><span class="code-s">,
		</span><span class="code-t">CellProperties</span><span class="code-s">::</span><span class="code-d">MOVE_DOWN </span><span class="code-s">| </span><span class="code-t">CellProperties</span><span class="code-s">::</span><span class="code-d">MOVE_DOWN_SIDE</span><span class="code-s">,
		</span><span class="code-t">Color</span><span class="code-s">::</span><span class="code-f">From2</span><span class="code-d">55</span><span class="code-s">(</span><span class="code-d">235</span><span class="code-s">, </span><span class="code-d">200</span><span class="code-s">, </span><span class="code-d">175</span><span class="code-s">)
	</span><span class="code-s">};
	
	</span><span class="code-w">_WATER </span><span class="code-s">= </span><span class="code-s">{
		</span><span class="code-t">CellType</span><span class="code-s">::</span><span class="code-d">WATER</span><span class="code-s">,
		</span><span class="code-t">CellProperties</span><span class="code-s">::</span><span class="code-d">MOVE_DOWN </span><span class="code-s">| </span><span class="code-t">CellProperties</span><span class="code-s">::</span><span class="code-d">MOVE_SIDE</span><span class="code-s">,
		</span><span class="code-t">Color</span><span class="code-s">::</span><span class="code-f">From2</span><span class="code-d">55</span><span class="code-s">(</span><span class="code-d">175</span><span class="code-s">, </span><span class="code-d">200</span><span class="code-s">, </span><span class="code-d">235</span><span class="code-s">)
	</span><span class="code-s">};
	
	</span><span class="code-w">_ROCK </span><span class="code-s">= </span><span class="code-s">{
		</span><span class="code-t">CellType</span><span class="code-s">::</span><span class="code-d">ROCK</span><span class="code-s">,
		</span><span class="code-t">CellProperties</span><span class="code-s">::</span><span class="code-d">NONE</span><span class="code-s">,
		</span><span class="code-t">Color</span><span class="code-s">::</span><span class="code-f">From2</span><span class="code-d">55</span><span class="code-s">(</span><span class="code-d">200</span><span class="code-s">, </span><span class="code-d">200</span><span class="code-s">, </span><span class="code-d">200</span><span class="code-s">)
	</span><span class="code-s">};
	
	</span><span class="code-c">// Init a texture for sand...
</span><span class="code-s">}
</span></pre>
			</div>
		<p>Then at the top of our update function, we'll add these lines.</p>
			<div class="article-code draw-left-line">
				
				<pre class="article-code-text cpp">
</span><span class="code-r">void </span><span class="code-f">Update</span><span class="code-s">(</span><span class="code-s">) </span><span class="code-s">{
	</span><span class="code-j">if </span><span class="code-s">(</span><span class="code-t">Mouse</span><span class="code-s">::</span><span class="code-f">ButtonDown</span><span class="code-s">(</span><span class="code-d">LMOUSE</span><span class="code-s">)</span><span class="code-s">) </span><span class="code-s">{
		</span><span class="code-t">vector2 </span><span class="code-v">pos </span><span class="code-s">= </span><span class="code-t">Mouse</span><span class="code-s">::</span><span class="code-f">ScreenPos</span><span class="code-s">(</span><span class="code-s">) </span><span class="code-s">/ </span><span class="code-w">m_world</span><span class="code-s">.</span><span class="code-w">m_scale;
		</span><span class="code-v">pos</span><span class="code-s">.</span><span class="code-w">y </span><span class="code-s">= </span><span class="code-w">m_world</span><span class="code-s">.</span><span class="code-w">m_height </span><span class="code-s">- </span><span class="code-v">pos</span><span class="code-s">.</span><span class="code-w">y;

		</span><span class="code-t">Cell </span><span class="code-v">placeMe </span><span class="code-s">= _EMPTY;

			</span><span class="code-j">if </span><span class="code-s">(</span><span class="code-t">Keyboard</span><span class="code-s">::</span><span class="code-f">KeyDown</span><span class="code-s">(</span><span class="code-d">S</span><span class="code-s">)</span><span class="code-s">) </span><span class="code-v">placeMe </span><span class="code-s">= </span><span class="code-w">_SAND;
		</span><span class="code-j">else </span><span class="code-j">if </span><span class="code-s">(</span><span class="code-t">Keyboard</span><span class="code-s">::</span><span class="code-f">KeyDown</span><span class="code-s">(</span><span class="code-d">W</span><span class="code-s">)</span><span class="code-s">) </span><span class="code-v">placeMe </span><span class="code-s">= </span><span class="code-w">_WATER;
		</span><span class="code-j">else </span><span class="code-j">if </span><span class="code-s">(</span><span class="code-t">Keyboard</span><span class="code-s">::</span><span class="code-f">KeyDown</span><span class="code-s">(</span><span class="code-d">R</span><span class="code-s">)</span><span class="code-s">) </span><span class="code-v">placeMe </span><span class="code-s">= </span><span class="code-w">_ROCK;

		</span><span class="code-j">for </span><span class="code-s">(</span><span class="code-t">size_t </span><span class="code-v">x </span><span class="code-s">= </span><span class="code-v">pos</span><span class="code-s">.</span><span class="code-w">x; </span><span class="code-v">x </span><span class="code-s">&lt </span><span class="code-v">pos</span><span class="code-s">.</span><span class="code-w">x </span><span class="code-s">+ </span><span class="code-d">20; </span><span class="code-v">x</span><span class="code-s">+</span><span class="code-s">+</span><span class="code-s">)
		</span><span class="code-j">for </span><span class="code-s">(</span><span class="code-t">size_t </span><span class="code-v">y </span><span class="code-s">= </span><span class="code-v">pos</span><span class="code-s">.</span><span class="code-w">y; </span><span class="code-v">y </span><span class="code-s">&lt </span><span class="code-v">pos</span><span class="code-s">.</span><span class="code-w">y </span><span class="code-s">+ </span><span class="code-d">20; </span><span class="code-v">y</span><span class="code-s">+</span><span class="code-s">+</span><span class="code-s">) 
		</span><span class="code-s">{
			</span><span class="code-j">if </span><span class="code-s">(</span><span class="code-s">!</span><span class="code-w">m_world</span><span class="code-s">.</span><span class="code-f">InBounds</span><span class="code-s">(</span><span class="code-v">x</span><span class="code-s">, </span><span class="code-v">y</span><span class="code-s">)</span><span class="code-s">) 
				</span><span class="code-j">continue;
			
			</span><span class="code-w">m_world</span><span class="code-s">.</span><span class="code-f">SetCell</span><span class="code-s">(</span><span class="code-v">x</span><span class="code-s">, </span><span class="code-v">y</span><span class="code-s">, </span><span class="code-v">placeMe</span><span class="code-s">);
		</span><span class="code-s">}
	</span><span class="code-s">}

	</span><span class="code-c">// Update cells
	</span><span class="code-c">// Copy sand colors to a texture
	</span><span class="code-c">// Draw the texture on the screen
</span><span class="code-s">}
</span></pre>
			</div>
		<p>The last thing I want to cover is about making games inside of these simulations. Let's think about the most basic feature we need, then in future posts I'll expand on this.</p><p>Having a player that moves around seems like a good place to start, so let's think about how that might work. We'll need some notion of a group of particles that can move together. Let's make a Tile struct that holds a list of positions for its particles, and a position for the group itself. For now, we'll just use the _ROCK particle for everything in the tile.</p>
			<div class="article-code draw-left-line">
				<p class="article-code-file mark-section">Tile.h</p>
				<pre class="article-code-text cpp">
</span><span class="code-r">struct </span><span class="code-t">Tile </span><span class="code-s">{
	</span><span class="code-w">std</span><span class="code-s">::</span><span class="code-t">vector</span><span class="code-s">&lt</span><span class="code-w">std</span><span class="code-s">::</span><span class="code-t">pair</span><span class="code-s">&lt</span><span class="code-r">int</span><span class="code-s">, </span><span class="code-r">int</span><span class="code-s">&gt</span><span class="code-s">&gt </span><span class="code-w">Positions;
	</span><span class="code-r">int </span><span class="code-w">X </span><span class="code-s">= </span><span class="code-d">0;
	</span><span class="code-r">int </span><span class="code-w">Y </span><span class="code-s">= </span><span class="code-d">0;
</span><span class="code-s">};
</span></pre>
			</div>
		<p>Before we update the world, we need to paste the tile particles in, so let's put these lines in the Update function before the main loops. After we've called CommitCells and updated the texture, we can remove the tiles by setting their cells to _EMPTY.</p>
			<div class="article-code draw-left-line">
				<p class="article-code-file mark-section">Main.cpp</p>
				<pre class="article-code-text cpp">
</span><span class="code-w">std</span><span class="code-s">::</span><span class="code-t">vector</span><span class="code-s">&lt</span><span class="code-t">Tile</span><span class="code-s">&gt </span><span class="code-w">m_tiles;

</span><span class="code-r">void </span><span class="code-f">Update</span><span class="code-s">(</span><span class="code-s">) </span><span class="code-s">{
	</span><span class="code-c">// Draw cells with mouse

	</span><span class="code-j">for </span><span class="code-s">(</span><span class="code-t">Tile</span><span class="code-s">& </span><span class="code-v">tile </span><span class="code-s">: </span><span class="code-w">m_tiles</span><span class="code-s">) </span><span class="code-s">{
		</span><span class="code-j">for </span><span class="code-s">(</span><span class="code-r">auto </span><span class="code-s">[</span><span class="code-v">x</span><span class="code-s">, </span><span class="code-v">y</span><span class="code-s">] </span><span class="code-s">: </span><span class="code-v">tile</span><span class="code-s">.</span><span class="code-w">Positions</span><span class="code-s">) </span><span class="code-s">{
			</span><span class="code-v">x </span><span class="code-s">+</span><span class="code-s">= </span><span class="code-v">tile</span><span class="code-s">.</span><span class="code-w">X;
			</span><span class="code-v">y </span><span class="code-s">+</span><span class="code-s">= </span><span class="code-v">tile</span><span class="code-s">.</span><span class="code-w">Y;

			</span><span class="code-j">if </span><span class="code-s">(</span><span class="code-w">m_world</span><span class="code-s">.</span><span class="code-f">InBounds</span><span class="code-s">(</span><span class="code-v">x</span><span class="code-s">, </span><span class="code-v">y</span><span class="code-s">)</span><span class="code-s">) </span><span class="code-s">{
				</span><span class="code-c">// what happens if the cell is already full?
				</span><span class="code-w">m_world</span><span class="code-s">.</span><span class="code-f">SetCell</span><span class="code-s">(</span><span class="code-v">x</span><span class="code-s">, </span><span class="code-v">y</span><span class="code-s">, </span><span class="code-w">_ROCK</span><span class="code-s">);
			</span><span class="code-s">}
		</span><span class="code-s">}
	</span><span class="code-s">}

	</span><span class="code-c">// Update cells
	</span><span class="code-c">// Copy sand colors to a texture
	</span><span class="code-c">// Draw the texture on the screen

	</span><span class="code-j">for </span><span class="code-s">(</span><span class="code-t">Tile</span><span class="code-s">& </span><span class="code-v">tile </span><span class="code-s">: </span><span class="code-w">m_tiles</span><span class="code-s">) </span><span class="code-s">{
		</span><span class="code-j">for </span><span class="code-s">(</span><span class="code-r">auto </span><span class="code-s">[</span><span class="code-v">x</span><span class="code-s">, </span><span class="code-v">y</span><span class="code-s">] </span><span class="code-s">: </span><span class="code-v">tile</span><span class="code-s">.</span><span class="code-w">Positions</span><span class="code-s">) </span><span class="code-s">{
			</span><span class="code-v">x </span><span class="code-s">+</span><span class="code-s">= </span><span class="code-v">tile</span><span class="code-s">.</span><span class="code-w">X;
			</span><span class="code-v">y </span><span class="code-s">+</span><span class="code-s">= </span><span class="code-v">tile</span><span class="code-s">.</span><span class="code-w">Y;

			</span><span class="code-j">if </span><span class="code-s">(</span><span class="code-w">m_world</span><span class="code-s">.</span><span class="code-f">InBounds</span><span class="code-s">(</span><span class="code-v">x</span><span class="code-s">, </span><span class="code-v">y</span><span class="code-s">)</span><span class="code-s">) </span><span class="code-s">{
				</span><span class="code-c">// what happens if the cell is no longer part of the tile?
				</span><span class="code-w">m_world</span><span class="code-s">.</span><span class="code-f">SetCell</span><span class="code-s">(</span><span class="code-v">x</span><span class="code-s">, </span><span class="code-v">y</span><span class="code-s">, </span><span class="code-w">_EMPTY</span><span class="code-s">);
			</span><span class="code-s">}
		</span><span class="code-s">}
	</span><span class="code-s">}
</span><span class="code-s">}
</span></pre>
			</div>
		<p>Finally, we can make a little ship and add some basic movement. In the Init function, we'll make a Tile and add it to the list.</p>
			<div class="article-code draw-left-line">
				
				<pre class="article-code-text cpp">
</span><span class="code-r">void </span><span class="code-f">Initialize</span><span class="code-s">(</span><span class="code-s">) </span><span class="code-s">{ 
	</span><span class="code-t">Tile </span><span class="code-v">ship </span><span class="code-s">= </span><span class="code-s">{
		</span><span class="code-s">{
					    </span><span class="code-s">{</span><span class="code-d">2</span><span class="code-s">,</span><span class="code-d">6</span><span class="code-s">}</span><span class="code-s">,
				  </span><span class="code-s">{</span><span class="code-d">1</span><span class="code-s">,</span><span class="code-d">5</span><span class="code-s">}</span><span class="code-s">, </span><span class="code-s">{</span><span class="code-d">2</span><span class="code-s">,</span><span class="code-d">5</span><span class="code-s">}</span><span class="code-s">, 
			</span><span class="code-s">{</span><span class="code-d">0</span><span class="code-s">,</span><span class="code-d">4</span><span class="code-s">}</span><span class="code-s">, </span><span class="code-s">{</span><span class="code-d">1</span><span class="code-s">,</span><span class="code-d">4</span><span class="code-s">}</span><span class="code-s">, </span><span class="code-s">{</span><span class="code-d">2</span><span class="code-s">,</span><span class="code-d">4</span><span class="code-s">}</span><span class="code-s">, </span><span class="code-s">{</span><span class="code-d">3</span><span class="code-s">,</span><span class="code-d">4</span><span class="code-s">}</span><span class="code-s">,
			</span><span class="code-s">{</span><span class="code-d">0</span><span class="code-s">,</span><span class="code-d">3</span><span class="code-s">}</span><span class="code-s">, </span><span class="code-s">{</span><span class="code-d">1</span><span class="code-s">,</span><span class="code-d">3</span><span class="code-s">}</span><span class="code-s">, </span><span class="code-s">{</span><span class="code-d">2</span><span class="code-s">,</span><span class="code-d">3</span><span class="code-s">}</span><span class="code-s">, </span><span class="code-s">{</span><span class="code-d">3</span><span class="code-s">,</span><span class="code-d">3</span><span class="code-s">}</span><span class="code-s">,
			</span><span class="code-s">{</span><span class="code-d">0</span><span class="code-s">,</span><span class="code-d">2</span><span class="code-s">}</span><span class="code-s">,               </span><span class="code-s">{</span><span class="code-d">3</span><span class="code-s">,</span><span class="code-d">2</span><span class="code-s">}</span><span class="code-s">,
			</span><span class="code-s">{</span><span class="code-d">0</span><span class="code-s">,</span><span class="code-d">1</span><span class="code-s">}</span><span class="code-s">,               </span><span class="code-s">{</span><span class="code-d">3</span><span class="code-s">,</span><span class="code-d">1</span><span class="code-s">}</span><span class="code-s">,
			</span><span class="code-s">{</span><span class="code-d">0</span><span class="code-s">,</span><span class="code-d">0</span><span class="code-s">}</span><span class="code-s">,               </span><span class="code-s">{</span><span class="code-d">3</span><span class="code-s">,</span><span class="code-d">0</span><span class="code-s">}</span><span class="code-s">,
		</span><span class="code-s">}</span><span class="code-s">,
		</span><span class="code-d">200</span><span class="code-s">, </span><span class="code-d">200
	</span><span class="code-s">};

	</span><span class="code-w">m_tiles</span><span class="code-s">.</span><span class="code-f">push_back</span><span class="code-s">(</span><span class="code-v">ship</span><span class="code-s">);

	</span><span class="code-c">// Create default cells
	</span><span class="code-c">// Init a texture for sand...
</span><span class="code-s">}
</span></pre>
			</div>
		<p>In the Update function, before the world updates, we can add these lines to move our ship. It's important to move the tiles before pasting them in so they can be removed correctly at the end.</p>
			<div class="article-code draw-left-line">
				
				<pre class="article-code-text cpp">
</span><span class="code-r">void </span><span class="code-f">Update</span><span class="code-s">(</span><span class="code-s">) </span><span class="code-s">{
	</span><span class="code-c">// Draw cells with mouse

	</span><span class="code-j">if </span><span class="code-s">(</span><span class="code-t">Keyboard</span><span class="code-s">::</span><span class="code-f">KeyDown</span><span class="code-s">(</span><span class="code-d">LEFT</span><span class="code-s">)</span><span class="code-s">)  </span><span class="code-w">m_tiles</span><span class="code-s">[</span><span class="code-d">0</span><span class="code-s">]</span><span class="code-s">.</span><span class="code-w">X </span><span class="code-s">-</span><span class="code-s">= </span><span class="code-d">1;
	</span><span class="code-j">if </span><span class="code-s">(</span><span class="code-t">Keyboard</span><span class="code-s">::</span><span class="code-f">KeyDown</span><span class="code-s">(</span><span class="code-d">RIGHT</span><span class="code-s">)</span><span class="code-s">) </span><span class="code-w">m_tiles</span><span class="code-s">[</span><span class="code-d">0</span><span class="code-s">]</span><span class="code-s">.</span><span class="code-w">X </span><span class="code-s">+</span><span class="code-s">= </span><span class="code-d">1;
	</span><span class="code-j">if </span><span class="code-s">(</span><span class="code-t">Keyboard</span><span class="code-s">::</span><span class="code-f">KeyDown</span><span class="code-s">(</span><span class="code-d">UP</span><span class="code-s">)</span><span class="code-s">)    </span><span class="code-w">m_tiles</span><span class="code-s">[</span><span class="code-d">0</span><span class="code-s">]</span><span class="code-s">.</span><span class="code-w">Y </span><span class="code-s">+</span><span class="code-s">= </span><span class="code-d">1;
	</span><span class="code-j">if </span><span class="code-s">(</span><span class="code-t">Keyboard</span><span class="code-s">::</span><span class="code-f">KeyDown</span><span class="code-s">(</span><span class="code-d">DOWN</span><span class="code-s">)</span><span class="code-s">)  </span><span class="code-w">m_tiles</span><span class="code-s">[</span><span class="code-d">0</span><span class="code-s">]</span><span class="code-s">.</span><span class="code-w">Y </span><span class="code-s">-</span><span class="code-s">= </span><span class="code-d">1;

	</span><span class="code-c">// Paste tiles
	</span><span class="code-c">// Update cells
	</span><span class="code-c">// Copy sand colors to a texture
	</span><span class="code-c">// Draw the texture on the screen
	</span><span class="code-c">// Remove tiles
</span><span class="code-s">}
</span></pre>
			</div>
		<p>And that about covers it, we're left with a decently quick simulation. On my computer this runs between 0.005 - .015 seconds per frame. Which is around 200 - 60 fps. Currently we can only use 1 thread, so if your computer has 4 cores we are only using 1/4th or more likely only 1/8th of its power :(</p>
			<span class="article-embed article-embed-thumb-yt-icon">
				<img class="article-embed-thumb" src="/thumbnails/_r8p1FOH9j0.jpg" onclick="swapIframe(this, 'https://www.youtube.com/embed/_r8p1FOH9j0?rel=0&modestbranding=1&autoplay=1')"></img>
			</span>
		<p>In the next post, I am going to cover how we could make the world bigger, and how multi-threading the simulation works. Then we'll make a game with it, so stay tuned if this seems interesting!</p>
			
			<div className="article-comment-section">
				<h2 className="article-subtitle mark-section" id="comments">Comments<a className="article-subtitle-id-link" href="#comments">#</a></h2>
				<br />
				<iframe class="comment-frame" scrolling="no" src="./external/comments.html?subject=falling-sand"></iframe>
			</div>
	   
		</div>
	</div>
	
	<script src="/scripts/swap_iframe.js"></script>
</body>

</html>